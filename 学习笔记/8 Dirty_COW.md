# Dirty_COW

## 知识点

1. **内存映射**：mmap() 系统调用。

   **MAP_DHARED**：对于映射内存的修改会反映到物理内存中，因此这样的改动对其他同样映射了这个文件的进程立即可见。

   **MAP_PRIVATE**：文件将映射到调用进程的私有的内存空间中，任何对该空间的改动对其他进程都不可见，底层文件也不会因此改动。

   **写时拷贝（cow）**：复制内存非常耗时，因此操作系统通常会延缓这个操作直到实际需要时才复制。

2. **madvise()**：此系统调用可以建议操作系统内核如何处理拷贝后的内存。

   **MADV_DONTNEED**：当此建议作为第三个参数时，告诉内核不再需要这部分内存地址空间了。因此内核会释放这部分地址空间的资源，并更改进程页表。

3. 映射只读文件：对只读文件（O_RDONLY方式打开）进行映射时，只能使用PROT_READ选项，否则映射会失败。映射后的内存会被标记为只读，但仍然可以进行内存访问操作，但可能是由于内存访问保护机制的影响，不能修改只读文件的内存映射。

   但在linux中，如果一个文件以MAP_PRIVATE模式映射的话，操作系统会作为特例处理，以另外的方式修改映射的只读内存。

4. write() ：对于写时拷贝类型的内存，write() 需要执行下面三个关键步骤：

   - 映射的物理内存做一份拷贝；
   - 更新页表，让虚拟内存指向新创建的物理内存；
   - 写入内存。

   但这几步操作并非原子化的，这几步的执行可以被其他线程打断。

5. **[question]**P154是否可以用两个进程来进行攻击，而不是两个线程？

6. **passwd文件**冒号之间各项的含义：第三个代表ID。

7. 创建新用户

   ```bash
   sudo adduser testcow
   ```

8. 

## 习题

## 实验

### Task 1: Modify a Dummy Read-Only File

攻击只在Ubuntu12.04生效，在我使用的Ubuntu16.04无效。



### Task 2: Modify the Password File to Gain the Root Privilege

> ​		现在，让我们对真实的系统文件发起攻击，以便获得root权限。我们选择`/etc/passwd`文件作为目标文件。此文件是全世界可读的，但非root用户无法修改它。该文件包含用户帐户信息，每个用户一条记录。假设我们的用户名是seed。以下行显示root和seed的记录
>
> ```
> root:x:0:0:root:/root:/bin/bash
> seed:x:1000:1000:Seed,123,,:/home/seed:/bin/bash
> ```
>
> ​		上述每条记录都包含七个冒号分隔的字段。我们感兴趣的是第三个字段，它指定分配给用户的用户ID（UID）值。UID是Linux中访问控制的主要基础，因此该值对安全性至关重要。根用户的UID字段包含一个特殊值0；这就是它成为超级用户的原因，而不是它的名字。UID为0的任何用户都将被系统视为root用户，无论其用户名是什么。seed用户的ID只有1000，因此它没有root权限。但是，如果我们可以将该值更改为0，则可以将其转换为root。我们将利用脏牛漏洞来实现这一目标。
>
> ​		在我们的实验中，我们将不使用seed帐户，因为本书中的大多数实验都使用该帐户；如果我们在实验结束后忘记把液体换回来，其他实验就会受到影响。相反，我们创建了一个名为charlie的新帐户，我们将使用脏牛攻击将这个普通用户转换为root用户。可以使用adduser命令添加新帐户。创建帐户后，将向/etc/passwd添加一条新记录。见下文：
>
> ```bash
> $ sudo adduser charlie
> ...
> $ cat /etc/passwd | grep charlie
> charlie:x:1001:1001:,,,:/home/charlie:/bin/bash
> ```
>
> ​		我们建议您保存`/etc/passwd`文件的副本，以防出错并损坏此文件。另一种方法是在使用此实验室之前拍摄虚拟机的快照，以便在虚拟机损坏时随时回滚。
>
> ​		**TASK.** 您需要在`/etc/passwd`中修改charlie的条目，因此第三个字段从1001更改为0000，基本上将charlie转换为根帐户。该文件无法写入charlie，但我们可以使用脏牛攻击写入此文件。您可以修改cow_attack.c程序从任务1开始实现这一目标。
>
> ​		攻击成功后，如果将用户切换到charlie，您应该能够在shell提示符处看到#符号，这是根shell的指示器。如果您运行id命令，您应该能够看到您已获得root权限。
>
> ```bash
> seed@ubuntu$ su charlie
> Passwd:
> root@ubuntu# id
> uid=0(root) gid=1001(charlie) groups=0(root),1001(charlie)
> ```

与书上一致

但攻击只在Ubuntu12.04生效，在我使用的Ubuntu16.04无效。

